I"Š<p>Suppose that we have a collection <span class="math inline">\(I = \{ 1, \ldots, k \}\)</span> of <span class="math inline">\(k\)</span> items where each item has positive, integral value <span class="math inline">\(v_i\)</span> and weight <span class="math inline">\(w_i\)</span>. The goal of the classic <em>knapsack problem</em> is to fill a backpack with capacity <span class="math inline">\(C\)</span> (a positive integer) with a subset of the items from <span class="math inline">\(I\)</span> such that the sum of the <em>weights</em> of the chosen items does not exceed <span class="math inline">\(C\)</span>. In the decision variant of this problem, we attempt to fill the knapsack so that the sum of values of the chosen items is equal to some target value <span class="math inline">\(t\)</span>. For this problem, weâ€™ll instead consider the maximization variant of this problem where we attempt to fill the knapsack so that the sum of the values is maximized while respecting the capacity of the knapsack.</p>
<p>As we discussed in class this week, the knapsack problem is clearly expressible as an 0-1 integer program and as such is known to be <span class="math inline">\(\mathsf{NP}\)</span>-hard. In this demonstration exercise, weâ€™ll develop an approximation algorithm for this problem by considering a number of <em>greedy</em> approaches.</p>
<h1 id="problem-1-by-value">Problem 1: By Value</h1>
<p>First, letâ€™s consider a simple algorithm utilizing the values of the items:</p>
<blockquote>
<p>First remove any items that do not fit in the knapsack, <em>i.e.</em>, an item <span class="math inline">\(i\)</span> such that <span class="math inline">\(w_i &gt; C\)</span>. Then, order the items in terms of <em>decreasing value</em> (most valuable item first) and add items to the knapsack until the knapsackâ€™s capacity would be exceeded by adding another item.</p>
</blockquote>
<p>Give an example instance of the knapsack problem where this algorithm <em>fails</em> to find the optimal solution. Also give the solution generated by the algorithm and what the optimal solution is.</p>
<h1 id="problem-2-by-ratio">Problem 2: By Ratio</h1>
<p>Obviously, a greedy algorithm that orders by weight instead of value would be a non-starter. However, what if we instead consider the <em>ratio</em> of value to weight for each item instead?</p>
<blockquote>
<p>First remove any items that do not fit in the knapsack, <em>i.e.</em>, an item <span class="math inline">\(i\)</span> such that <span class="math inline">\(w_i &gt; C\)</span>. Then, order the items in terms of <em>decreasing value-weight ratio</em>, <em>i.e.</em>, <span class="math inline">\(\frac{v_i}{w_i}\)</span> for item <span class="math inline">\(i\)</span>, and add items to the knapsack until the knapsackâ€™s capacity would be exceeded by adding another item.</p>
</blockquote>
<p>Give an example instance of the knapsack problem where this algorithm also <em>fails</em> to find the optimal solution. Give the solution generated by the algorithm and what the optimal solution is.</p>
<h1 id="problem-3-surprise">Problem 3: Surprise</h1>
<p>The by-ratio algorithm seems to be superior to the by-value algorithm. However, it turns out this is not always the case!</p>
<p>Give a <em>pair</em> of example instances, one where the by-ratio algorithm outperforms the by-value algorithm and one where the by-value algorithm outperforms the by-ratio algorithm. Again, report the solutions generated by each algorithm and the optimal solutions for each of the instances.</p>
<p>(<em>Hint</em>: you may not have to look hard to find these examplesâ€”check problems 1 and 2 again!)</p>
<h1 id="problem-4-why-not-both">Problem 4: Why Not Both?</h1>
<p>The previous problem suggests an intriguing approach: why not try both algorithms and take the better of the two?</p>
<blockquote>
<p>Run the by-value and by-ratio algorithms and use the solution that generates the higher value.</p>
</blockquote>
:ET