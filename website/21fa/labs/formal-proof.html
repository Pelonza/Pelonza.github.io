<!DOCTYPE html>

<html>
  <head>
    <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Formal Proof</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css">
  <link rel="stylesheet" href="/csc341/css/style.css">
  <link rel="stylesheet" href="/csc341/css/syntax.css">
  <link rel="stylesheet" href="/csc341/css/syntax-drracket.css">
  <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
  
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  
  
</head>

  </head>
  <body>
    <nav class="navbar is-primary" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="/csc341/">
      <img src="/csc341/img/laurel-white.png">
      &nbsp;
      CSC 341 (21fa)
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      <a class="navbar-item" href="/csc341/syllabus">
        Syllabus
      </a>
      <a class="navbar-item" href="/csc341/resources">
        Resources
      </a>
      
      <a class="navbar-item" href="https://teams.microsoft.com/l/team/19%3avJm8Wpx7VaDe72Q53lhFS8hKbE8ZqBMHkz-HLvwbzag1%40thread.tacv2/conversations?groupId=621c250a-ec62-4c30-afbd-0e3b7efa7606&tenantId=524f9e3e-faca-4f64-b3ec-adb2baee8807
">Teams</a>
      
      
      <a class="navbar-item" href="https://www.gradescope.com/courses/299977
">Gradescope</a>
      
      <a class="navbar-item" href="/csc341/editor">
        Editor
      </a>
    </div>
  </div>
</nav>

<!-- Adapted from: https://bulma.io/documentation/components/navbar/ -->
<script>
  document.addEventListener('DOMContentLoaded', () => {

    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

    // Check if there are any navbar burgers
    if ($navbarBurgers.length > 0) {

      // Add a click event on each of them
      $navbarBurgers.forEach( el => {
        el.addEventListener('click', () => {

          // Get the target from the "data-target" attribute
          const target = el.dataset.target;
          const $target = document.getElementById(target);

          // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
          el.classList.toggle('is-active');
          $target.classList.toggle('is-active');

        });
      });
    }

  });
</script>

    <section class="section">
      <div class="container">
        <h1 class="title">
          CSC 341 (Fall 2021)
        </h1>
        <h1 class="subtitle">
          
            Lab: Formal Proof
          
        </h1>
      </div>
    </section>
    <section class="content">
      <div class="container">
        
        <p>In this lab, we’ll work on authoring proofs. Try to be as rigorous, yet concise in your proofs as possible. If you have any questions about levels of formality or formatting, please don’t hesitate to ask!</p>
<h2 id="problem-1-formal-proof">Problem 1: Formal Proof</h2>
<p>Formally prove the following claims over strings.</p>
<div class="claim">
<p><strong>Claim 1</strong>: Call an element <span class="math inline">\(u\)</span> of a set <span class="math inline">\(S\)</span> and an associated binary operation over that set <span class="math inline">\((+) : S → S\)</span> a <em>unit</em> if <span class="math inline">\(\forall x \in S \ldotp x + u = u + x = x\)</span>. We claim that <span class="math inline">\(ϵ\)</span> is a unit for strings and concatenation over strings.</p>
</div>
<div class="claim">
<p><strong>Claim 2</strong>: Let <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> be strings. If <span class="math inline">\(x\)</span> is a prefix of <span class="math inline">\(y\)</span> and <span class="math inline">\(y\)</span> is a prefix of <span class="math inline">\(x\)</span> then <span class="math inline">\(x = y\)</span>.</p>
</div>
<p>(<em>Hint</em>: make this an algebraic argument based on the definition of prefix from the book!)</p>
<h2 id="problem-2-induction-revisited">Problem 2: Induction Revisited</h2>
<p>Consider the following definitions regarding binary trees.</p>
<div class="definition">
<p><strong>Definition (Binary Tree)</strong>: a binary tree is either:</p>
<ul>
<li>A <em>leaf</em> or</li>
<li>A <em>node</em> with two sub-trees, its <em>children</em>.</li>
</ul>
<p>We define the <em>root</em> of a binary tree to be a node that is not the child of any other node in the tree.</p>
</div>
<div class="definition">
<p><strong>Definition (Level and Height)</strong>: the <em>level</em> of a node in a binary tree is the length of the path from the root to that node. The <em>height</em> of a binary tree is the maximal level of any node in the tree. We also use “level” to denote the <em>set of all nodes</em> that share the same level in the tree.</p>
</div>
<div class="definition">
<p><strong>Definition (Complete and Perfect Trees)</strong>: a tree is <em>complete</em> if each of its levels contain its maximal number of possible nodes. A tree is <em>perfect</em> if each node of the tree contains zero or two children.</p>
</div>
<p>Now prove the following claim by structural induction.</p>
<div class="claim">
<p>Let <span class="math inline">\(h\)</span> be the height of a complete, perfect binary tree. If <span class="math inline">\(n \leq h\)</span>, then there are <span class="math inline">\(2^n\)</span> nodes at level <span class="math inline">\(n\)</span> of this tree.</p>
</div>
<h2 id="problem-3-constructive-proof-optional">Problem 3: Constructive Proof (Optional)</h2>
<p>Chess is played on a <span class="math inline">\(n \times n\)</span> board (usually <span class="math inline">\(n = 8\)</span>). Consider the <em>rook</em> piece, which can move in any number of squares in a cardinal (non-diagonal) direction. A <em>rook’s tour</em> is a sequence of moves for a single rook that causes the piece to visit <em>every</em> square of the board <em>exactly once</em>. When considering a tour, we are free to place our piece on the board at any position initially. Also, we only consider a square visited if the piece <em>ends its movement</em> on that square.</p>
<p>Prove via induction that there exists a rook’s tour for any chessboard of size <span class="math inline">\(n ≥ 1\)</span>.</p>
<p>(<em>Hint 1</em>: note that proving the existence of a rook’s tour means constructing a rook’s tour for an arbitrary board, <em>i.e.</em>, designing an algorithm that generates the tour!)</p>
<p>(<em>Hint 2:</em> pay attention to the details! This is not as straightforward of a proof as you might think!)</p>

      </div>
    </section>
    <footer class="footer is-size-7 has-text-centered">
  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br/>
  Made with <a href="https://bulma.io">Bulma</a>, <a href="https://jekyllrb.com">Jekyll</a>, <a href="https://www.brailleinstitute.org/freefont">Atkinson Hyperlegible</a>, and <a href="https://github.com/JetBrains/JetBrainsMono">JetBrains Mono</a>.
</footer>

  </body>
</html>
