<!DOCTYPE html>

<html>
  <head>
    <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rice's Theorem</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css">
  <link rel="stylesheet" href="/csc341/css/style.css">
  <link rel="stylesheet" href="/csc341/css/syntax.css">
  <link rel="stylesheet" href="/csc341/css/syntax-drracket.css">
  <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
  
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  
  
</head>

  </head>
  <body>
    <nav class="navbar is-primary" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="/csc341/">
      <img src="/csc341/img/laurel-white.png">
      &nbsp;
      CSC 341 (21fa)
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      <a class="navbar-item" href="/csc341/syllabus">
        Syllabus
      </a>
      <a class="navbar-item" href="/csc341/resources">
        Resources
      </a>
      
      <a class="navbar-item" href="https://teams.microsoft.com/l/team/19%3avJm8Wpx7VaDe72Q53lhFS8hKbE8ZqBMHkz-HLvwbzag1%40thread.tacv2/conversations?groupId=621c250a-ec62-4c30-afbd-0e3b7efa7606&tenantId=524f9e3e-faca-4f64-b3ec-adb2baee8807
">Teams</a>
      
      
      <a class="navbar-item" href="https://www.gradescope.com/courses/299977
">Gradescope</a>
      
      <a class="navbar-item" href="/csc341/editor">
        Editor
      </a>
    </div>
  </div>
</nav>

<!-- Adapted from: https://bulma.io/documentation/components/navbar/ -->
<script>
  document.addEventListener('DOMContentLoaded', () => {

    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

    // Check if there are any navbar burgers
    if ($navbarBurgers.length > 0) {

      // Add a click event on each of them
      $navbarBurgers.forEach( el => {
        el.addEventListener('click', () => {

          // Get the target from the "data-target" attribute
          const target = el.dataset.target;
          const $target = document.getElementById(target);

          // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
          el.classList.toggle('is-active');
          $target.classList.toggle('is-active');

        });
      });
    }

  });
</script>

    <section class="section">
      <div class="container">
        <h1 class="title">
          CSC 341 (Fall 2021)
        </h1>
        <h1 class="subtitle">
          
            Reading: Rice's Theorem
          
        </h1>
      </div>
    </section>
    <section class="content">
      <div class="container">
        
        <p><span class="math display">\[
\newcommand{\desc}[1]{\langle #1 \rangle}
\]</span></p>
<h1 id="rices-theorem">Rice’s Theorem</h1>
<p>This week, we have studied a multitude of undecidable languages, most of them involving the analysis of different models of computation. After all of this, it may seem that most decision procedures that analyze the behavior of machines, in particular, Turing machines may be undecidable. Rice’s Theorem answers this in the affirmative:</p>
<div class="definition">
<p><strong>Theorem (Rice’s Theorem)</strong>: let <span class="math inline">\(P\)</span> a property about Turing machines, formalized as a language consisting of Turing machine descriptions. If:</p>
<ol type="1">
<li><span class="math inline">\(P\)</span> is non-trivial: <span class="math inline">\(|P| &gt; 0\)</span> and there exists some Turing machine <span class="math inline">\(M\)</span> such that <span class="math inline">\(\desc{M} ∉ P\)</span>.</li>
<li><span class="math inline">\(P\)</span> is a property about the language of the Turing machine: if <span class="math inline">\(L(M_1) = L(M_2)\)</span> then <span class="math inline">\(\desc{M_1} ∈ P ⇔ \desc{M_2} ∈ P\)</span>.</li>
</ol>
<p>Then P is undecidable.</p>
</div>
<p>We’ll prove this theorem in class on Friday. In this reading, we’ll discuss the practical ramifications of this theorem.</p>
<h2 id="alternative-proof-technique-for-undecidability">Alternative Proof Technique for Undecidability</h2>
<p>We can use Rice’s Theorem to directly prove that a language is undecidable by showing that the language fulfills the two conditions of the theorem.</p>
<div class="proof">
<p><strong>Claim</strong>: <span class="math inline">\(E_{\mathsf{TM}} = \{\, \desc{M} \mid \text{\( M \) is a TM and \( L(M) = \emptyset \)} \,\}\)</span> is undecidable.</p>
<p><em>Proof</em>. By Rice’s theorem, we must show that <span class="math inline">\(E_{TM}\)</span> satisfies two properties:</p>
<ol type="1">
<li><p>Non-trivial.</p>
<ul>
<li>A TM where there is no path from the start state to the accept state is in <span class="math inline">\(E_{TM}\)</span>, so <span class="math inline">\(|E_{TM}| &gt; 0\)</span>.</li>
<li>A TM whose initial state transitions on a blank to its accept state is not in <span class="math inline">\(E_{TM}\)</span> (its language is <span class="math inline">\(\{\, ϵ \,\}\)</span>), so there exists a TM not in <span class="math inline">\(E_{TM}\)</span>.</li>
</ul></li>
<li><p>Language property. Suppose that we have two Turing machines <span class="math inline">\(M_1\)</span> and <span class="math inline">\(M_2\)</span> such that <span class="math inline">\(L(M_1) = L(M_2)\)</span>. We only need to prove the left-to-right <span class="math inline">\((\Longrightarrow)\)</span> direction of the biconditional since the right-to-left direction is symmetric.</p></li>
</ol>
<ul>
<li><span class="math inline">\((\Longrightarrow)\)</span>: Suppose that <span class="math inline">\(\desc{M_1} \in E_{\mathsf{TM}}\)</span>. Thus <span class="math inline">\(L(M_1) = ∅\)</span> and by transitivity, <span class="math inline">\(L(M_2) = \emptyset\)</span> and thus <span class="math inline">\(M_2 \in E_{\mathsf{TM}}\)</span> as well.</li>
</ul>
</div>
<p>Note that Rice’s Theorem only applies to non-trivial properties. For trivial languages, a deciding TM can always be constructed for such properties that either accepts or rejects every input Turing machine.</p>
<p>It is also important to note that Rice’s Theorem concerns <em>language properties</em> and not <em>machine properties</em>. A language property of a Turing machine is a function of the language of the machine. A machine property, in contrast, is a function of the <em>behavior</em> of the machine. For example:</p>
<blockquote>
<p><span class="math inline">\(L = \{\, \desc{M} \mid \text{\( M \) is a TM and \( M \) writes a 0 to the tape during execution on some input} \,\}\)</span></p>
</blockquote>
<p>Is a machine property. For example, two machines <span class="math inline">\(M_1\)</span> and <span class="math inline">\(M_2\)</span> could write a 0 to the tape on input <span class="math inline">\(001\)</span>, but <span class="math inline">\(M_1\)</span> may accept <span class="math inline">\(001\)</span> whereas <span class="math inline">\(M_2\)</span> rejects it. While this property is undecidable, Rice’s Theorem does not apply to it.</p>
<h2 id="practical-realities">Practical Realities</h2>
<p>Even if we don’t go off to study the theory of computation in graduate school, Rice’s Theorem has several important implications for us as software developers. Recall that we postulate that Turing machines are capable of expressing any computation possible by a (classical) computer. Dually, we say that a programming language is <em>Turing-complete</em> if it is capable of expressing any computation that a computer could conceivably perform. Most programming languages that we think of are Turing-complete, including many things—language features, games, and hardware—that we wouldn’t think are capable of such expressiveness; the <a href="https://en.wikipedia.org/wiki/Turing_completeness">Wikipedia article on Turing-completeness</a> gives several examples.</p>
<p>Rice’s Theorem tells us that because Turing-complete programming languages are equivalent in expressiveness to Turing machines (with a caveat that we discuss shortly), then <em>analysis of non-trivial properties of program behavior</em> written in these languages is undecidable. A popular example of this is <span class="math inline">\(\mathsf{HALT}_{\mathsf{TM}}\)</span>, the halting problem for Turing machines which we know is undecidable. Because of this, we know that the halting problem for Python or Java is also undecidable. In other words, we can’t write an algorithm to detect whether an arbitrary Python or Java program halts on an arbitrary input.</p>
<p>While most developers are not writing program analysis tools, they <em>use</em> development tools that are, by the nature of undecidability, at the boundaries of the limits of computation! This has several important implications that we’ll now explore briefly. The first is the <a href="https://en.wikipedia.org/wiki/Full_employment_theorem"><em>Full Employment Theorem for Compiler Writers</em></a>.</p>
<div class="proof">
<p><strong>Theorem (Full Employment Theorem for Compiler Writers)</strong>: there cannot exist a compiler that fully optimizes all programs in a Turing-complete programming language.</p>
<p><em>Proof</em>. Suppose for the sake of contradiction that there exists a fully optimizing compiler for a Turing-complete programming language, say Java. Consider a Java function <code>f</code> that performs arbitrary computation. If <code>f</code> goes into an infinite loop, then such a fully optimizing compiler would optimize <code>f</code> to the follow minimized form:</p>
<pre><code>public static void f() {
    while(true) { }
}</code></pre>
<p>Such a compiler could then be used to detect whether <code>f</code> goes into an infinite loop: compile the program and inspect the optimized output to see if it is in the minimized form.</p>
</div>
<p>The full employment theorem is called as such because a compiler writer’s job is never done. A consequence of this theorem is that for any optimizing compiler, there must always be some program that it cannot fully optimize. Therefore a compiler writer can always improve their compiler (although it may not be practical to do so)! As users of compilers, we should realize that while modern compilers are powerful, we can’t expect perfection from them in all cases; there will always be room for manual elbow grease when optimizing our programs.</p>
<p>Another consequence of Rice’s Theorem is that our development tools have both theoretical and practice limits. For example. Consider the following Java code:</p>
<pre><code>public static void g() {
    int x;
    // stuff happens...
    System.out.println(x);
}</code></pre>
<p>We would like the compiler to warn us when we have such <em>uninitialized variables</em>. And we might have an intuition about how to proceed: from the definition of <code>x</code>, ensure that is has been assigned to at least once before it is used. So we would need to check the <code>// stuff happens...</code> block to ensure that <code>x</code> has been given a value.</p>
<p>However, the halting problem can be easily solved if we had such a procedure to check whether a variable is initialized. For example, what if the commented block is the code:</p>
<pre><code>    while (/* some arbitrary condition */) { }    // potentially an infinite loop
    x = 5;</code></pre>
<p>Then <code>x</code> is initialized if and only if the while-loop is not an infinite loop. (Also, we never hit the <code>println</code> if the while-loop is infinite, but that’s not our concern for the purposes of analyzing whether <code>x</code> is initialized.)</p>
<p>So checking for uninitialized variables is an undecidable problem. Nevertheless, the Java compiler is seemingly able to detect uninitialized variables! The following code:</p>
<pre><code>public static void f() {
    int x;
    System.out.println(x);
}</code></pre>
<p>Produces the following error:</p>
<pre><code>$ javac T.java
T.java:4: error: variable x might not have been initialized
        System.out.println(x);
                           ^
1 error</code></pre>
<p>What can we infer about the situation given that we know the problem is theoretically undecidable? It must be the case that either (a) Java is not a Turing-complete language so it is possible to decide this property for all possible input programs or (b) an approximation is happening. Indeed (b) is the case that is happening here! For example consider the following Java program:</p>
<pre><code>public static boolean alwaysTrue() {
    return true;
}

public static void f() {
    int x;
    if (alwaysTrue()) { x = 5; }
    System.out.println(x);
}</code></pre>
<p>Clearly <code>alwaysTrue</code> works as advertised, so we always go into the conditional and initialize <code>x</code>. Nevertheless, this code produces the same error as before:</p>
<pre><code>$ javac T.java
T.java:10: error: variable x might not have been initialized
        System.out.println(x);
                           ^
1 error</code></pre>
<p>In practice, static analyses of code are necessarily <em>conservative</em> as a result of Rice’s Theorem.</p>
<ul>
<li>If a piece of code definitely has an uninitialized variable, the Java compiler will definitely report so.</li>
<li>However, code that may not have uninitialized variables may be flagged by the compiler as having such errors.</li>
</ul>
<p>As a result, many static analysis tools produce <em>false negatives</em>—cases where a property is not violated but the tool says that the property is violated. This doesn’t mean that we should not trust static analysis tools! As developers, we need to recognize that these problems are an inevitable result of having to navigate around the limitations of computation. We may have to rewrite our code to remove such false negatives, or we will need to be willing tolerate this “noise” in our compilation processes without otherwise ignoring the usefulness of the tool.</p>

      </div>
    </section>
    <footer class="footer is-size-7 has-text-centered">
  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br/>
  Made with <a href="https://bulma.io">Bulma</a>, <a href="https://jekyllrb.com">Jekyll</a>, <a href="https://www.brailleinstitute.org/freefont">Atkinson Hyperlegible</a>, and <a href="https://github.com/JetBrains/JetBrainsMono">JetBrains Mono</a>.
</footer>

  </body>
</html>
